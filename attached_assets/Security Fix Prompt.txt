Please update the FiLot Telegram bot codebase—designed as an agentic system that can autonomously recommend and execute liquidity-pool trades—to fix all identified security vulnerabilities while preserving its agentic capabilities. The entire stack is Python-based. Specifically, implement the following changes:

1. Replace Mocks with Real On-Chain Calls

In solana_wallet_service.py and any balance-fetch modules, swap mock methods for real RPC calls to Solana (mainnet, with devnet for testing). Include robust error handling, retries, and clear user-facing error messages.


2. Enforce Explicit, Agent-Mediated Confirmation

Before the agent autonomously builds or sends any transaction, generate a detailed “preview” message in Telegram that shows wallet address, token pair, amount, estimated fees, slippage, and projected outcome. Require the user to press a confirmation button (“Confirm Trade” or “Cancel”) before calling send_transaction().


3. Secure, Persistent WalletConnect Sessions in Python

Replace in-memory self.sessions = {} with an encrypted, persistent store (e.g. Redis or an encrypted SQLite/PostgreSQL table accessed via SQLAlchemy). Ensure sessions are scoped per Telegram user ID + wallet, expire after idle timeout, and cannot be reused across users.


4. Whitelist & Validate External Data

In your Raydium client module (e.g. raydium_client.py), validate every pool address, token mint, and APR value against a trusted whitelist or by cross-referencing at least two independent sources. The agent must refuse to recommend or act on pools that fail validation.


5. Sanitize All Inputs for Autonomous Commands

Use Pydantic or Marshmallow to strictly define and validate schemas for every Telegram command and callback payload. Reject messages containing unexpected fields, overly long strings, or injection patterns.


6. Rate Limit Agent Actions & API Calls

Implement per-user rate limiting using a Python middleware or decorator (e.g. aiolimiter or Redis-backed token bucket). Throttle both Telegram handlers and internal API calls to prevent loops or DoS.


7. Enforce User Context & Permission Boundaries

In every agent decision and transaction, bind context to update.effective_user.id (Telegram user ID) and the linked wallet address. Before executing any action, verify context continuity (ensure the same user and wallet).


8. Mask Sensitive Data in Logs

Use Python’s logging module with custom filters to redact WalletConnect URIs, symmetric keys, private keys, and seed phrases. Only log URI prefixes (e.g. uri[:8] + '...') and store full values encrypted in memory.


9. Slippage & Anomaly Detection Guardrails

Enforce a default agent-enforced slippage tolerance (e.g. 0.5%) on all swap calls, with an upper bound that cannot be overridden.

Implement simple anomaly detection on transaction size/frequency (e.g. using rolling statistics in Redis); if thresholds are exceeded, the agent must pause and request manual confirmation.


10. Centralize Security Policies in a Python Module

Create a new security_service.py (or security.py) to encapsulate all guards: transaction simulation, input validation, session checks, rate limiting, data whitelisting, and anomaly detection. Refactor the agent’s core loop to call these policies before executing any action.


11. Unit & Integration Tests for Autonomous Flows

Write pytest tests simulating malicious inputs (fake pool addresses, spoofed APR data, session reuse) and ensure the agent safely rejects or handles each case. Cover both user-initiated and fully autonomous agent actions.


12. Security Documentation & Audit Trail

Generate user-facing docs that explain the agent’s permissions, confirmation flows, and slippage settings.

Implement structured, PII-safe logs for all agent decisions (previews, confirms, rejections, anomalies), with timestamps and user IDs.